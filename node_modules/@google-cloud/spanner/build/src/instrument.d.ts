/*!
 * Copyright 2024 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Span, TracerProvider } from '@opentelemetry/api';
interface SQLStatement {
    sql: string;
}
interface ObservabilityOptions {
    tracerProvider: TracerProvider;
    enableExtendedTracing?: boolean;
    enableEndToEndTracing?: boolean;
}
export type { ObservabilityOptions };
export type { Span };
declare const TRACER_NAME = "cloud.google.com/nodejs/spanner";
declare const TRACER_VERSION: any;
export { TRACER_NAME, TRACER_VERSION };
/**
 * getTracer fetches the tracer from the provided tracerProvider.
 * @param {TracerProvider} [tracerProvider] optional custom tracer provider
 * to use for fetching the tracer. If not provided, the global provider will be used.
 *
 * @returns {Tracer} The tracer instance associated with the provided or global provider.
 */
export declare function getTracer(tracerProvider?: TracerProvider): import("@opentelemetry/api").Tracer;
interface traceConfig {
    sql?: string | SQLStatement;
    tableName?: string;
    dbName?: string;
    transactionTag?: string | null;
    requestTag?: string | null;
    opts?: ObservabilityOptions;
}
declare const SPAN_NAMESPACE_PREFIX = "CloudSpanner";
export { SPAN_NAMESPACE_PREFIX, traceConfig };
declare function ensureInitialContextManagerSet(): void;
export { ensureInitialContextManagerSet };
/**
 * startTrace begins an active span in the current active context
 * and passes it back to the set callback function. Each span will
 * be prefixed with "cloud.google.com/nodejs/spanner". It is the
 * responsibility of the caller to invoke [span.end] when finished tracing.
 *
 * @returns {Span} The created span.
 */
export declare function startTrace<T>(spanNameSuffix: string, config: traceConfig | undefined, cb: (span: Span) => T): T;
/**
 * Sets the span status with err, if non-null onto the span with
 * status.code=ERROR and the message of err.toString()
 *
 * @returns {boolean} to signify if the status was set.
 */
export declare function setSpanError(span: Span, err: Error | String): boolean;
/**
 * Sets err, if non-null onto the span with
 * status.code=ERROR and the message of err.toString()
 * as well as recording an exception on the span.
 * @param {Span} [span] the subject span
 * @param {Error} [err] the error whose message to use to record
 * the span error and the span exception.
 *
 * @returns {boolean} to signify if the status and exception were set.
 */
export declare function setSpanErrorAndException(span: Span, err: Error | String): boolean;
/**
 * getActiveOrNoopSpan queries the global tracer for the currently active
 * span and returns it, otherwise if there is no active span available, it'll
 * simply create a NoopSpan. This is important in the cases where we don't
 * want to create a new span, such as in sensitive and frequently called code
 * for which the new spans would be too many and thus pollute the trace,
 * but yet we'd like to record an important annotation.
 *
 * @returns {Span} the non-null span.
 */
export declare function getActiveOrNoopSpan(): Span;
