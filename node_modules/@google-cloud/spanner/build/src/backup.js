"use strict";
/**
 * Copyright 2020 Google LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backup = void 0;
const promisify_1 = require("@google-cloud/promisify");
const common_1 = require("./common");
const _1 = require(".");
const google_gax_1 = require("google-gax");
const precise_date_1 = require("@google-cloud/precise-date");
/**
 * The {@link Backup} class represents a Cloud Spanner backup.
 *
 * Create a `Backup` object to interact with or create a Cloud Spanner backup or copy a backup.
 *
 * @class
 *
 * @example
 * ```
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const backup = instance.backup('my-backup');
 * ```
 *
 * ```
 * * @example
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const sourceBackup = instance.backup('my-source-backup');
 * const copyBackup = instance.copyBackup('my-copy-backup', 'my-source-backup');
 * ```
 */
class Backup {
    constructor(instance, name, sourceName) {
        this.request = instance.request;
        this.instanceFormattedName_ = instance.formattedName_;
        this.formattedName_ = Backup.formatName_(instance.formattedName_, name);
        this.id = this.formattedName_.split('/').pop() || '';
        this.sourceName = sourceName;
        this.resourceHeader_ = {
            [common_1.CLOUD_RESOURCE_HEADER]: this.instanceFormattedName_,
        };
    }
    create(options, callback) {
        const gaxOpts = options.gaxOptions;
        if ('databasePath' in options) {
            const reqOpts = {
                parent: this.instanceFormattedName_,
                backupId: this.id,
                backup: {
                    database: options.databasePath,
                    expireTime: _1.Spanner.timestamp(options.expireTime).toStruct(),
                    name: this.formattedName_,
                },
            };
            if ('versionTime' in options) {
                reqOpts.backup.versionTime = _1.Spanner.timestamp(options.versionTime).toStruct();
            }
            if ('encryptionConfig' in options &&
                options.encryptionConfig) {
                reqOpts.encryptionConfig = options.encryptionConfig;
            }
            this.request({
                client: 'DatabaseAdminClient',
                method: 'createBackup',
                reqOpts,
                gaxOpts,
                headers: this.resourceHeader_,
            }, (err, operation, resp) => {
                if (err) {
                    callback(err, null, null, resp);
                    return;
                }
                callback(null, this, operation, resp);
            });
        }
        else if (this.sourceName) {
            delete options.gaxOptions;
            options.backupId = this.id;
            options.parent = this.instanceFormattedName_;
            options.sourceBackup = this.sourceName;
            this.request({
                client: 'DatabaseAdminClient',
                method: 'copyBackup',
                reqOpts: options,
                gaxOpts,
                headers: this.resourceHeader_,
            }, (err, operation, resp) => {
                if (err) {
                    callback(err, null, null, resp);
                    return;
                }
                callback(null, this, operation, resp);
            });
        }
    }
    getMetadata(gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            name: this.formattedName_,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'getBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, response) => {
            if (response) {
                this.metadata = response;
            }
            callback(err, response);
        });
    }
    async getState() {
        const [backupInfo] = await this.getMetadata();
        return backupInfo.state;
    }
    async getExpireTime() {
        const [backupInfo] = await this.getMetadata();
        return new precise_date_1.PreciseDate(backupInfo.expireTime);
    }
    async exists() {
        try {
            // Attempt to read metadata to determine whether backup exists
            await this.getMetadata();
            // Found therefore it exists
            return true;
        }
        catch (err) {
            if (err.code === google_gax_1.grpc.status.NOT_FOUND) {
                return false;
            }
            // Some other error occurred, rethrow
            throw err;
        }
    }
    updateExpireTime(expireTime, gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            backup: {
                name: this.formattedName_,
                expireTime: _1.Spanner.timestamp(expireTime).toStruct(),
            },
            updateMask: {
                paths: ['expire_time'],
            },
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'updateBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, response) => {
            callback(err, response);
        });
    }
    delete(gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            name: this.formattedName_,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'deleteBackup',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, err => {
            callback(err);
        });
    }
    /**
     * Format the backup name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * ```
     * Backup.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-backup'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/backups/my-backup'
     * ```
     */
    static formatName_(instanceName, name) {
        if (name.indexOf('/') > -1) {
            return name;
        }
        const backupName = name.split('/').pop();
        return instanceName + '/backups/' + backupName;
    }
}
exports.Backup = Backup;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.promisifyAll)(Backup, {
    exclude: ['getState', 'getExpireTime', 'exists'],
});
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.callbackifyAll)(Backup, {
    exclude: ['create', 'getMetadata', 'updateExpireTime', 'delete'],
});
//# sourceMappingURL=backup.js.map