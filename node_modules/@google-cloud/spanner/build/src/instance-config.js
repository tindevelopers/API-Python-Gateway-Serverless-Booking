"use strict";
/**
 * Copyright 2022 Google LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceConfig = void 0;
const common = require('./common-grpc/service-object');
const snakeCase = require("lodash.snakecase");
const common_1 = require("./common");
const promisify_1 = require("@google-cloud/promisify");
const google_gax_1 = require("google-gax");
const extend = require("extend");
/**
 * The {@link InstanceConfig} class represents a possible configuration for a
 * Cloud Spanner instance.
 *
 * Create an `InstanceConfig` object to interact with a Cloud Spanner instance
 * config.
 *
 * @class
 *
 * @param {Spanner} spanner {@link Spanner} instance.
 * @param {string} name Name of the instance config.
 *
 * @example
 * ```
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instanceConfig('my-instance-config');
 * ```
 */
class InstanceConfig extends common.GrpcServiceObject {
    constructor(spanner, name) {
        const formattedName_ = InstanceConfig.formatName_(spanner.projectId, name);
        const methods = {
            /**
             * Create an instance config.
             *
             * Wrapper around {@link v1.InstanceAdminClient#createInstanceConfig}.
             *
             * @see {@link v1.InstanceAdminClient#createInstanceConfig}
             * @see [CreateInstanceConfig API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.instance.v1#google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig)
             *
             * @method InstanceConfig#create
             * @param {CreateInstanceConfigRequest} config Configuration object.
             * @param {CreateInstanceConfigCallback} [callback] Callback function.
             * @returns {Promise<CreateInstanceConfigResponse>}
             *
             * @example
             * ```
             * const {Spanner} = require('@google-cloud/spanner');
             * const spanner = new Spanner();
             *
             * const instanceConfig =
             *     spanner.instanceConfig('custom-my-instance-config');
             *
             * instanceConfig.create(function(err, instance, operation, apiResponse) {
             *   if (err) {
             *     // Error handling omitted.
             *   }
             *
             *   operation
             *     .on('error', function(err) {})
             *     .on('complete', function() {
             *       // Instance config created successfully.
             *     });
             * });
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * instanceConfig.create()
             *   .then(function(data) {
             *     const operation = data[0];
             *     const apiResponse = data[1];
             *
             *     return operation.promise();
             *   })
             *   .then(function() {
             *     // Instance config created successfully.
             *   });
             * ```
             */
            create: true,
        };
        super({
            parent: spanner,
            id: name,
            methods,
            createMethod(_, options, callback) {
                spanner.createInstanceConfig(formattedName_, options, callback);
            },
        });
        this.formattedName_ = formattedName_;
        this.request = spanner.request.bind(spanner);
        this.resourceHeader_ = {
            [common_1.CLOUD_RESOURCE_HEADER]: this.formattedName_,
        };
    }
    get(optionsOrCallback, cb) {
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        this.parent.getInstanceConfig(this.id, options, callback);
    }
    setMetadata(config, callback) {
        const reqOpts = {
            instanceConfig: extend({
                name: this.formattedName_,
            }, config.instanceConfig),
            updateMask: {
                paths: Object.keys(config.instanceConfig).map(snakeCase),
            },
            validateOnly: config.validateOnly,
        };
        // validateOnly need not be passed in if it is null or undefined.
        if (reqOpts.validateOnly === null || reqOpts.validateOnly === undefined)
            delete reqOpts.validateOnly;
        return this.request({
            client: 'InstanceAdminClient',
            method: 'updateInstanceConfig',
            reqOpts,
            gaxOpts: config.gaxOpts === null || config.gaxOpts === undefined
                ? {}
                : config.gaxOpts,
            headers: this.resourceHeader_,
        }, callback);
    }
    delete(optionsOrCallback, cb) {
        const config = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            name: this.formattedName_,
            etag: config.etag,
            validateOnly: config.validateOnly,
        };
        // etag/validateOnly need not be passed in if null or undefined.
        if (reqOpts.etag === null || reqOpts.etag === undefined)
            delete reqOpts.etag;
        if (reqOpts.validateOnly === null || reqOpts.etag === undefined)
            delete reqOpts.validateOnly;
        this.request({
            client: 'InstanceAdminClient',
            method: 'deleteInstanceConfig',
            reqOpts,
            gaxOpts: config.gaxOpts === null || config.gaxOpts === undefined
                ? {}
                : config.gaxOpts,
            headers: this.resourceHeader_,
        }, (err, resp) => {
            if (!err) {
                this.parent.instanceConfigs_.delete(this.id);
            }
            callback(err, resp);
        });
    }
    async exists() {
        try {
            // Attempt to read metadata to determine whether instance config exists
            await this.get();
            // Found, therefore it exists
            return true;
        }
        catch (err) {
            if (err.code === google_gax_1.grpc.status.NOT_FOUND) {
                return false;
            }
            // Some other error occurred, rethrow
            throw err;
        }
    }
    /**
     * Format the instance config name to include the project ID.
     *
     * @private
     *
     * @param {string} projectId The project ID.
     * @param {string} name The instance config name.
     * @returns {string}
     *
     * @example
     * ```
     * InstanceConfig.formatName_('grape-spaceship-123', 'my-instance-config');
     * // 'projects/grape-spaceship-123/instanceConfigs/my-instance-config'
     * ```
     */
    static formatName_(projectId, name) {
        if (name.indexOf('/') > -1) {
            return name;
        }
        const instanceConfigName = name.split('/').pop();
        return 'projects/' + projectId + '/instanceConfigs/' + instanceConfigName;
    }
}
exports.InstanceConfig = InstanceConfig;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.promisifyAll)(InstanceConfig, {
    exclude: ['exists'],
});
//# sourceMappingURL=instance-config.js.map