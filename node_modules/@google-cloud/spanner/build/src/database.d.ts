/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ExistsCallback, GetConfig } from '@google-cloud/common';
declare const common: any;
import * as r from 'teeny-request';
import { CallOptions, Operation as GaxOperation } from 'google-gax';
import { BatchTransaction, TransactionIdentifier } from './batch-transaction';
import { SessionFactoryInterface } from './session-factory';
import { google as databaseAdmin, google, google as spannerClient } from '../protos/protos';
import IsolationLevel = google.spanner.v1.TransactionOptions.IsolationLevel;
import { GetDatabaseOperationsOptions, GetDatabaseOperationsResponse, Instance, GetDatabaseOperationsCallback } from './instance';
import { PartialResultStream } from './partial-result-stream';
import { Session } from './session';
import { SessionPoolCloseCallback, SessionPoolInterface, SessionPoolOptions } from './session-pool';
import { CreateTableCallback, CreateTableResponse, Table } from './table';
import { BatchWriteOptions, CommitCallback, CommitResponse, ExecuteSqlRequest, MutationGroup, MutationSet, RunCallback, RunResponse, RunUpdateCallback, Snapshot, TimestampBounds, Transaction } from './transaction';
import { AsyncRunTransactionCallback, RunTransactionCallback, RunTransactionOptions } from './transaction-runner';
import { IOperation, LongRunningCallback, NormalCallback, PagedOptionsWithFilter, PagedResponse, RequestCallback, ResourceCallback, Schema } from './common';
import { Duplex, Readable } from 'stream';
import { EnumKey, RequestConfig, TranslateEnumKeys } from '.';
import IPolicy = google.iam.v1.IPolicy;
import Policy = google.iam.v1.Policy;
import FieldMask = google.protobuf.FieldMask;
import IDatabase = google.spanner.admin.database.v1.IDatabase;
import { ObservabilityOptions } from './instrument';
export type GetDatabaseRolesCallback = RequestCallback<IDatabaseRole, databaseAdmin.spanner.admin.database.v1.IListDatabaseRolesResponse>;
export type GetDatabaseRolesResponse = PagedResponse<IDatabaseRole, databaseAdmin.spanner.admin.database.v1.IListDatabaseRolesResponse>;
type SetDatabaseMetadataCallback = ResourceCallback<GaxOperation, IOperation>;
type SetDatabaseMetadataResponse = [GaxOperation, IOperation];
type IDatabaseRole = databaseAdmin.spanner.admin.database.v1.IDatabaseRole;
type CreateBatchTransactionCallback = ResourceCallback<BatchTransaction, google.spanner.v1.ITransaction | google.spanner.v1.ISession>;
type CreateBatchTransactionResponse = [
    BatchTransaction,
    google.spanner.v1.ITransaction | google.spanner.v1.ISession
];
type DatabaseResponse = [Database, r.Response];
type DatabaseCallback = ResourceCallback<Database, r.Response>;
type GetSnapshotCallback = NormalCallback<Snapshot>;
type GetTransactionCallback = NormalCallback<Transaction>;
export interface SessionPoolConstructor {
    new (database: Database, options?: SessionPoolOptions | null): SessionPoolInterface;
}
export type GetDatabaseDialectCallback = NormalCallback<EnumKey<typeof google.spanner.admin.database.v1.DatabaseDialect>>;
export interface SetIamPolicyRequest {
    policy: Policy | null;
    updateMask?: FieldMask | null;
}
export interface RunPartitionedUpdateOptions extends ExecuteSqlRequest {
    excludeTxnFromChangeStreams?: boolean;
}
export type UpdateSchemaCallback = ResourceCallback<GaxOperation, databaseAdmin.longrunning.IOperation>;
export type UpdateSchemaResponse = [
    GaxOperation,
    databaseAdmin.longrunning.IOperation
];
type PoolRequestCallback = RequestCallback<Session>;
export type GetSessionsOptions = PagedOptionsWithFilter;
export type GetDatabaseRolesOptions = PagedOptionsWithFilter;
/**
 * IDatabase structure with database state enum translated to string form.
 */
type IDatabaseTranslatedEnum = Omit<TranslateEnumKeys<databaseAdmin.spanner.admin.database.v1.IDatabase, 'state', typeof databaseAdmin.spanner.admin.database.v1.Database.State>, 'restoreInfo'> & Omit<TranslateEnumKeys<databaseAdmin.spanner.admin.database.v1.IDatabase, 'databaseDialect', typeof databaseAdmin.spanner.admin.database.v1.DatabaseDialect>, 'restoreInfo'> & {
    restoreInfo?: IRestoreInfoTranslatedEnum | null;
};
/**
 * IRestoreInfo structure with restore source type enum translated to string form.
 */
type IRestoreInfoTranslatedEnum = TranslateEnumKeys<databaseAdmin.spanner.admin.database.v1.IRestoreInfo, 'sourceType', typeof databaseAdmin.spanner.admin.database.v1.RestoreSourceType>;
type GetDatabaseMetadataResponse = [IDatabaseTranslatedEnum];
type GetDatabaseMetadataCallback = RequestCallback<IDatabaseTranslatedEnum>;
type GetSchemaCallback = RequestCallback<string, databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse>;
type GetSchemaResponse = [
    string[],
    databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse
];
type GetIamPolicyResponse = IPolicy;
type GetIamPolicyCallback = RequestCallback<IPolicy>;
type SetIamPolicyResponse = IPolicy;
type SetIamPolicyCallback = RequestCallback<IPolicy>;
type GetSessionsCallback = RequestCallback<Session, google.spanner.v1.IListSessionsResponse>;
type GetSessionsResponse = PagedResponse<Session, google.spanner.v1.IListSessionsResponse>;
export type GetDatabaseConfig = GetConfig & databaseAdmin.spanner.admin.database.v1.IGetDatabaseRequest & {
    gaxOptions?: CallOptions;
};
type DatabaseCloseResponse = [google.protobuf.IEmpty];
export type CreateSessionResponse = [
    Session,
    spannerClient.spanner.v1.ISession
];
export interface CreateSessionOptions {
    labels?: {
        [k: string]: string;
    } | null;
    databaseRole?: string | null;
    gaxOptions?: CallOptions;
    multiplexed?: boolean;
}
export interface GetIamPolicyOptions {
    requestedPolicyVersion?: number | null;
    gaxOptions?: CallOptions;
}
/**
 * @typedef {object} GetTransactionOptions
 * * @property {boolean} [optimisticLock] The optimistic lock a
 *     {@link Transaction} should use while running.
 */
export type GetTransactionOptions = Omit<RunTransactionOptions, 'timeout'>;
export type CreateSessionCallback = ResourceCallback<Session, spannerClient.spanner.v1.ISession>;
export interface BatchCreateSessionsOptions extends CreateSessionOptions {
    count: number;
}
export type BatchCreateSessionsResponse = [
    Session[],
    spannerClient.spanner.v1.IBatchCreateSessionsResponse
];
export type BatchCreateSessionsCallback = ResourceCallback<Session[], spannerClient.spanner.v1.IBatchCreateSessionsResponse>;
export type DatabaseDeleteResponse = [databaseAdmin.protobuf.IEmpty];
export type DatabaseDeleteCallback = NormalCallback<databaseAdmin.protobuf.IEmpty>;
export interface CancelableDuplex extends Duplex {
    cancel(): void;
}
export type RestoreDatabaseCallback = LongRunningCallback<Database>;
export type RestoreDatabaseResponse = [
    Database,
    GaxOperation,
    databaseAdmin.longrunning.IOperation
];
export type GetRestoreInfoCallback = NormalCallback<IRestoreInfoTranslatedEnum>;
export type GetStateCallback = NormalCallback<EnumKey<typeof databaseAdmin.spanner.admin.database.v1.Database.State>>;
interface DatabaseRequest {
    (config: RequestConfig, callback: ResourceCallback<GaxOperation, IOperation>): void;
    <T>(config: RequestConfig, callback: RequestCallback<T>): void;
    <T, R>(config: RequestConfig, callback: RequestCallback<T, R>): void;
}
export interface RestoreOptions {
    encryptionConfig?: databaseAdmin.spanner.admin.database.v1.IRestoreDatabaseEncryptionConfig;
    gaxOptions?: CallOptions;
}
export interface WriteAtLeastOnceOptions extends CallOptions {
    isolationLevel?: IsolationLevel;
}
/**
 * Create a Database object to interact with a Cloud Spanner database.
 *
 * @class
 *
 * @param {string} name Name of the database.
 * @param {SessionPoolOptions|SessionPoolInterface} options Session pool
 *     configuration options or custom pool interface.
 * @param {google.spanner.v1.ExecuteSqlRequest.IQueryOptions} queryOptions
 *     The default query options to use for queries on the database.
 *
 * @example
 * ```
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const database = instance.database('my-database');
 * ```
 */
declare class Database extends common.GrpcServiceObject {
    private instance;
    formattedName_: string;
    pool_: SessionPoolInterface;
    sessionFactory_: SessionFactoryInterface;
    queryOptions_?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    commonHeaders_: {
        [k: string]: string;
    };
    request: DatabaseRequest;
    databaseRole?: string | null;
    labels?: {
        [k: string]: string;
    } | null;
    databaseDialect?: EnumKey<typeof databaseAdmin.spanner.admin.database.v1.DatabaseDialect> | null;
    _observabilityOptions?: ObservabilityOptions;
    private _traceConfig;
    private _nthRequest;
    _clientId: number;
    constructor(instance: Instance, name: string, poolOptions?: SessionPoolConstructor | SessionPoolOptions, queryOptions?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions);
    _nextNthRequest(): number;
    /**
     * @typedef {array} SetDatabaseMetadataResponse
     * @property {object} 0 The {@link Database} metadata.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback SetDatabaseMetadataCallback
     * @param {?Error} err Request error, if any.
     * @param {object} metadata The {@link Database} metadata.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Update the metadata for this database. Note that this method follows PATCH
     * semantics, so previously-configured settings will persist.
     *
     * Wrapper around {@link v1.DatabaseAdminClient#updateDatabase}.
     *
     * @see {@link v1.DatabaseAdminClient#updateDatabase}
     * @see [UpdateDatabase API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabase)
     *
     * @param {object} metadata The metadata you wish to set.
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {SetDatabaseMetadataCallback} [callback] Callback function.
     * @returns {Promise<SetDatabaseMetadataResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const metadata = {
     *   enableDropProtection: true
     * };
     *
     * database.setMetadata(metadata, function(err, operation, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   operation
     *     .on('error', function(err) {})
     *     .on('complete', function() {
     *       // Metadata updated successfully.
     *     });
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.setMetadata(metadata).then(function(data) {
     *   const operation = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    setMetadata(metadata: IDatabase, gaxOptions?: CallOptions): Promise<SetDatabaseMetadataResponse>;
    setMetadata(metadata: IDatabase, callback: SetDatabaseMetadataCallback): void;
    setMetadata(metadata: IDatabase, gaxOptions: CallOptions, callback: SetDatabaseMetadataCallback): void;
    static getEnvironmentQueryOptions(): databaseAdmin.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    /**
     * @typedef {object} BatchCreateSessionsOptions
     * @property {number} count The number of sessions to create.
     * @property {object.<string, string>} [labels] Labels to apply to each
     *     session.
     * @property {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @typedef {array} BatchCreateSessionsResponse
     * @property {Session[]} 0 The newly created sessions.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback BatchCreateSessionsCallback
     * @param {?Error} err Request error, if any.
     * @param {Session[]} sessions The newly created sessions.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Create a batch of sessions, which can be used to perform transactions that
     * read and/or modify data.
     *
     * **It is unlikely you will need to interact with sessions directly. By
     * default, sessions are created and utilized for maximum performance
     * automatically.**
     *
     * Wrapper around {@link v1.SpannerClient#batchCreateSessions}.
     *
     * @see {@link v1.SpannerClient#batchCreateSessions}
     * @see [BatchCreateSessions API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.BatchCreateSessions)
     *
     * @param {number|BatchCreateSessionsOptions} options Desired session count or
     *     a configuration object.
     * @param {BatchCreateSessionsCallback} [callback] Callback function.
     * @returns {Promise<BatchCreateSessionsResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const count = 5;
     *
     * database.batchCreateSession(count, (err, sessions, response) => {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   // `sessions` is an array of Session objects.
     * });
     *
     * ```
     * @example If the callback is omitted, we'll return a Promise.
     * ```
     * const [sessions, response] = await database.batchCreateSessions(count);
     * ```
     */
    batchCreateSessions(options: number | BatchCreateSessionsOptions): Promise<BatchCreateSessionsResponse>;
    batchCreateSessions(options: number | BatchCreateSessionsOptions, callback: BatchCreateSessionsCallback): void;
    _metadataWithRequestId(nthRequest: number, attempt: number, priorMetadata?: {
        [k: string]: string;
    }): {
        [k: string]: string;
    };
    /**
     * Get a reference to a {@link BatchTransaction} object.
     *
     * @see {@link BatchTransaction#identifier} to generate an identifier.
     *
     * @param {TransactionIdentifier} identifier The transaction identifier.
     * @param {object} [options] [Transaction options](https://cloud.google.com/spanner/docs/timestamp-bounds).
     * @returns {BatchTransaction} A batch transaction object.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const transaction = database.batchTransaction({
     *   session: 'my-session',
     *   transaction: 'my-transaction',
     *   readTimestamp: 1518464696657
     * });
     * ```
     */
    batchTransaction(identifier: TransactionIdentifier, options?: TimestampBounds): BatchTransaction;
    /**
     * @callback CloseDatabaseCallback
     * @param {?Error} err Request error, if any.
     */
    /**
     * Close the database connection and destroy all sessions associated with it.
     *
     * @param {CloseDatabaseCallback} [callback] Callback function.
     * @returns {Promise}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.close(function(err) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     * });
     *
     * //-
     * // In the event of a session leak, the error object will contain a
     * // `messages` field.
     * //-
     * database.close(function(err) {
     *   if (err && err.messages) {
     *     err.messages.forEach(function(message) {
     *       console.error(message);
     *     });
     *   }
     * });
     * ```
     */
    close(callback: SessionPoolCloseCallback): void;
    close(): Promise<DatabaseCloseResponse>;
    /**
     * @typedef {array} CreateTransactionResponse
     * @property {BatchTransaction} 0 The {@link BatchTransaction}.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback CreateTransactionCallback
     * @param {?Error} err Request error, if any.
     * @param {BatchTransaction} transaction The {@link BatchTransaction}.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Create a transaction that can be used for batch querying.
     *
     * @param {object} [options] [Transaction options](https://cloud.google.com/spanner/docs/timestamp-bounds).
     * @param {CreateTransactionCallback} [callback] Callback function.
     * @returns {Promise<CreateTransactionResponse>}
     */
    createBatchTransaction(options?: TimestampBounds): Promise<CreateBatchTransactionResponse>;
    createBatchTransaction(callback: CreateBatchTransactionCallback): void;
    createBatchTransaction(options: TimestampBounds, callback: CreateBatchTransactionCallback): void;
    /**
     * Create a new session.
     *
     * @typedef {object} CreateSessionOptions
     * @property {Object.<string, string>} [labels] The labels for the session.
     *
     *   * Label keys must be between 1 and 63 characters long and must conform to
     *     the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
     *   * Label values must be between 0 and 63 characters long and must conform
     *     to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
     *   * No more than 64 labels can be associated with a given session.
     * @property {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @typedef {array} CreateSessionResponse
     * @property {Session} 0 The newly created session.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback CreateSessionCallback
     * @param {?Error} err Request error, if any.
     * @param {Session} session The newly created session.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Create a new session, which can be used to perform transactions that read
     * and/or modify data.
     *
     * Sessions can only execute one transaction at a time. To execute multiple
     * concurrent read-write/write-only transactions, create multiple sessions.
     * Note that standalone reads and queries use a transaction internally, and
     * count toward the one transaction limit.
     *
     * **It is unlikely you will need to interact with sessions directly. By
     * default, sessions are created and utilized for maximum performance
     * automatically.**
     *
     * Wrapper around {@link v1.SpannerClient#createSession}.
     *
     * @see {@link v1.SpannerClient#createSession}
     * @see [CreateSession API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.CreateSession)
     *
     * @param {CreateSessionOptions} [options] Configuration object.
     * @param {CreateSessionCallback} [callback] Callback function.
     * @returns {Promise<CreateSessionResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.createSession(function(err, session, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   // `session` is a Session object.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.createSession().then(function(data) {
     *   const session = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    createSession(options: CreateSessionOptions): Promise<CreateSessionResponse>;
    createSession(callback: CreateSessionCallback): void;
    createSession(options: CreateSessionOptions, callback: CreateSessionCallback): void;
    /**
     * @typedef {array} CreateTableResponse
     * @property {Table} 0 The new {@link Table}.
     * @property {google.longrunning.Operation} 1 An {@link Operation} object that can be used to check
     *     the status of the request.
     * @property {object} 2 The full API response.
     */
    /**
     * @callback CreateTableCallback
     * @param {?Error} err Request error, if any.
     * @param {Table} table The new {@link Table}.
     * @param {google.longrunning.Operation} operation An {@link Operation} object that can be used to
     *     check the status of the request.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Create a table.
     *
     * Wrapper around {@link Database#updateSchema}.
     *
     * @see {@link Database#updateSchema}
     *
     * @param {string} schema A DDL CREATE statement describing the table.
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {CreateTableCallback} [callback] Callback function.
     * @returns {Promise<CreateTableResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const schema =
     *   'CREATE TABLE Singers (' +
     *   '  SingerId INT64 NOT NULL,' +
     *   '  FirstName STRING(1024),' +
     *   '  LastName STRING(1024),' +
     *   '  SingerInfo BYTES(MAX),' +
     *   ') PRIMARY KEY(SingerId)';
     *
     * database.createTable(schema, function(err, table, operation, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   operation
     *     .on('error', function(err) {})
     *     .on('complete', function() {
     *       // Table created successfully.
     *     });
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.createTable(schema)
     *   .then(function(data) {
     *     const table = data[0];
     *     const operation = data[1];
     *
     *     return operation.promise();
     *   })
     *   .then(function() {
     *     // Table created successfully.
     *   });
     * ```
     */
    createTable(schema: Schema, gaxOptions?: CallOptions): Promise<CreateTableResponse>;
    createTable(schema: Schema, callback: CreateTableCallback): void;
    createTable(schema: Schema, gaxOptions: CallOptions, callback: CreateTableCallback): void;
    /**
     * Decorates transaction so that when end() is called it will return the session
     * back into the pool.
     *
     * @private
     *
     * @param {Session} session The session to release.
     * @param {Transaction} transaction The transaction to observe.
     * @returns {Transaction}
     */
    private _releaseOnEnd;
    /**
     * @typedef {array} DatabaseDeleteResponse
     * @property {object} 0 The full API response.
     */
    /**
     * @callback DatabaseDeleteCallback
     * @param {?Error} err Request error, if any.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Delete the database.
     *
     * Wrapper around {@link v1.DatabaseAdminClient#dropDatabase}.
     *
     * @see {@link v1.DatabaseAdminClient#dropDatabase}
     * @see [DropDatabase API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.DatabaseAdmin.DropDatabase)
     *
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {DatabaseDeleteCallback} [callback] Callback function.
     * @returns {Promise<DatabaseDeleteResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.delete(function(err, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   // Database was deleted successfully.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.delete().then(function(data) {
     *   const apiResponse = data[0];
     * });
     * ```
     */
    delete(gaxOptions?: CallOptions): Promise<DatabaseDeleteResponse>;
    delete(callback: DatabaseDeleteCallback): void;
    delete(gaxOptions: CallOptions, callback: DatabaseDeleteCallback): void;
    /**
     * @typedef {array} DatabaseExistsResponse
     * @property {boolean} 0 Whether the {@link Database} exists.
     */
    /**
     * @callback DatabaseExistsCallback
     * @param {?Error} err Request error, if any.
     * @param {boolean} exists Whether the {@link Database} exists.
     */
    /**
     * Check if a database exists.
     *
     * @method Database#exists
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {DatabaseExistsCallback} [callback] Callback function.
     * @returns {Promise<DatabaseExistsResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.exists(function(err, exists) {});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.exists().then(function(data) {
     *   const exists = data[0];
     * });
     * ```
     */
    exists(gaxOptions?: CallOptions): Promise<[boolean]>;
    exists(callback: ExistsCallback): void;
    exists(gaxOptions: CallOptions, callback: ExistsCallback): void;
    /**
     * @typedef {array} GetDatabaseResponse
     * @property {Database} 0 The {@link Database}.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetDatabaseCallback
     * @param {?Error} err Request error, if any.
     * @param {Database} database The {@link Database}.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Get a database if it exists.
     *
     * You may optionally use this to "get or create" an object by providing an
     * object with `autoCreate` set to `true`. Any extra configuration that is
     * normally required for the `create` method must be contained within this
     * object as well.
     *
     * @param {options} [options] Configuration object.
     * @param {boolean} [options.autoCreate=false] Automatically create the
     *     object if it does not exist.
     * @param {object} [options.gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetDatabaseCallback} [callback] Callback function.
     * @returns {Promise<GetDatabaseResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.get(function(err, database, apiResponse) {
     *   // `database.metadata` has been populated.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.get().then(function(data) {
     *   const database = data[0];
     *   const apiResponse = data[0];
     * });
     * ```
     */
    get(options?: GetDatabaseConfig): Promise<DatabaseResponse>;
    get(callback: DatabaseCallback): void;
    get(options: GetDatabaseConfig, callback: DatabaseCallback): void;
    /**
     * @typedef {array} GetDatabaseMetadataResponse
     * @property {object} 0 The {@link Database} metadata.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetDatabaseMetadataCallback
     * @param {?Error} err Request error, if any.
     * @param {object} metadata The {@link Database} metadata.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Get the database's metadata.
     *
     * Wrapper around {@link v1.DatabaseAdminClient#getDatabase}.
     *
     * @see {@link v1.DatabaseAdminClient#getDatabase}
     * @see [GetDatabase API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.DatabaseAdmin.GetDatabase)
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetDatabaseMetadataCallback} [callback] Callback function.
     * @returns {Promise<GetDatabaseMetadataResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getMetadata(function(err, metadata) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   // Database was deleted successfully.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.getMetadata().then(function(data) {
     *   const metadata = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    getMetadata(gaxOptions?: CallOptions): Promise<GetDatabaseMetadataResponse>;
    getMetadata(callback: GetDatabaseMetadataCallback): void;
    getMetadata(gaxOptions: CallOptions, callback: GetDatabaseMetadataCallback): void;
    /**
     * {@link google.spanner.admin.database.v1#RestoreInfo} structure with restore
     * source type enum translated to string form.
     *
     * @typedef {object} IRestoreInfoTranslatedEnum
     */
    /**
     * @callback GetRestoreInfoCallback
     * @param {?Error} err Request error, if any.
     * @param {IRestoreInfoTranslatedEnum | undefined} restoreInfo Contains the restore
     *     information for the database if it was restored from a backup.
     */
    /**
     * Retrieves the restore information of the database.
     *
     * @see {@link #getMetadata}
     *
     * @method Database#getRestoreInfo
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetRestoreInfoCallback} [callback] Callback function.
     * @returns {Promise<IRestoreInfoTranslatedEnum | undefined>} When resolved,
     *     contains the restore information for the database if it was restored
     *     from a backup.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const restoreInfo = await database.getRestoreInfo();
     * console.log(`Database restored from ${restoreInfo.backupInfo.backup}`);
     * ```
     */
    getRestoreInfo(options?: CallOptions): Promise<IRestoreInfoTranslatedEnum | undefined>;
    getRestoreInfo(callback: GetRestoreInfoCallback): void;
    getRestoreInfo(options: CallOptions, callback: GetRestoreInfoCallback): void;
    /**
     * @callback GetStateCallback
     * @param {?Error} err Request error, if any.
     * @param {EnumKey<typeof, google.spanner.admin.database.v1.Database.State> | undefined} state
     *     Contains the current state of the database if the state is defined.
     */
    /**
     * Retrieves the state of the database.
     *
     * The database state indicates if the database is ready after creation or
     * after being restored from a backup.
     *
     * @see {@link #getMetadata}
     *
     * @method Database#getState
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetStateCallback} [callback] Callback function.
     * @returns {Promise<EnumKey<typeof, google.spanner.admin.database.v1.Database.State> | undefined>}
     *     When resolved, contains the current state of the database if the state
     *     is defined.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const state = await database.getState();
     * const isReady = (state === 'READY');
     * ```
     */
    getState(options?: CallOptions): Promise<EnumKey<typeof databaseAdmin.spanner.admin.database.v1.Database.State> | undefined>;
    getState(callback: GetStateCallback): void;
    getState(options: CallOptions, callback: GetStateCallback): void;
    /**
     * Retrieves the dialect of the database
     *
     * @see {@link #getMetadata}
     *
     * @method Database#getDatabaseDialect
     *
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetDatabaseDialectCallback} [callback] Callback function.
     * @returns {Promise<EnumKey<typeof, databaseAdmin.spanner.admin.database.v1.DatabaseDialect> | undefined>}
     * When resolved, contains the database dialect of the database if the dialect is defined.
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const dialect = await database.getDatabaseDialect();
     * const isGoogleSQL = (dialect === 'GOOGLE_STANDARD_SQL');
     * const isPostgreSQL = (dialect === 'POSTGRESQL');
     */
    getDatabaseDialect(options?: CallOptions): Promise<EnumKey<typeof databaseAdmin.spanner.admin.database.v1.DatabaseDialect> | undefined>;
    getDatabaseDialect(callback: GetDatabaseDialectCallback): void;
    getDatabaseDialect(options: CallOptions, callback: GetDatabaseDialectCallback): void;
    /**
     * @typedef {array} GetSchemaResponse
     * @property {string[]} 0 An array of database DDL statements.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetSchemaCallback
     * @param {?Error} err Request error, if any.
     * @param {string[]} statements An array of database DDL statements.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Get this database's schema as a list of formatted DDL statements.
     *
     * Wrapper around {@link v1.DatabaseAdminClient#getDatabaseDdl}.
     *
     * @see {@link v1.DatabaseAdminClient#getDatabaseDdl}
     * @see [Data Definition Language (DDL)](https://cloud.google.com/spanner/docs/data-definition-language)
     * @see [GetDatabaseDdl API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl)
     *
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetSchemaCallback} [callback] Callback function.
     * @returns {Promise<GetSchemaResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSchema(function(err, statements, apiResponse) {});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.getSchema().then(function(data) {
     *   const statements = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    getSchema(options?: CallOptions): Promise<GetSchemaResponse>;
    getSchema(callback: GetSchemaCallback): void;
    getSchema(options: CallOptions, callback: GetSchemaCallback): void;
    /**
     * Options object for requested policy version.
     *
     * @typedef {object} GetIamPolicyOptions
     * @property {number|null} [requestedPolicyVersion] policy version requested, possible values are 0, 1 and 3,
     *     See {@link https://cloud.google.com/iam/docs/policies#versions} for more details
     * @property {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @callback GetIamPolicyCallback
     * @param {?Error} err Request error, if any.
     * @param {google.iam.v1.Policy| undefined} policy Returns policy for the give database
     */
    /**
     * Retrieves the policy of the database.
     *
     * A Policy is a collection of bindings. A binding binds one or more members, or principals,
     * to a single role. Principals can be user accounts, service accounts, Google groups, and
     * domains (such as G Suite). A role is a named list of permissions; each role can be an IAM
     * predefined role or a user-created custom role.
     *
     * @see {@link #getIamPolicy}
     *
     * @method Database#getIamPolicy
     * @param {object} [options] requestedPolicyVersion and gax options(configuration options)
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html}
     *     for more details on gax options.
     * @param {GetIamPolicyCallback} [callback] Callback function.
     * @returns {Promise<Policy | undefined>}
     *     When resolved, contains the current policy of the database.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const policy = await database.getIamPolicy();
     * console.log(policy.bindings, policy.version, policy.etag, policy.auditConfigs)
     * const policyWithVersion specified = await database.getIamPolicy({requestedPolicyVersion: 3});
     * ```
     */
    getIamPolicy(options?: GetIamPolicyOptions): Promise<GetIamPolicyResponse>;
    getIamPolicy(callback: GetIamPolicyCallback): void;
    getIamPolicy(options: GetIamPolicyOptions, callback: GetIamPolicyCallback): void;
    /**
     * Options object for listing sessions.
     *
     * @typedef {object} GetSessionsOptions
     * @property {string} [filter] An expression for filtering the results of the
     *     request. Filter rules are case insensitive. The fields eligible for
     *     filtering are:
     *     - **`name`**
     *     - **`display_name`**
     *     - **`labels.key`** where key is the name of a label
     *
     *     Some examples of using filters are:
     *     - **`name:*`** The instance has a name.
     *     - **`name:Howl`** The instance's name is howl.
     *     - **`labels.env:*`** The instance has the label env.
     *     - **`labels.env:dev`** The instance's label env has the value dev.
     *     - **`name:howl labels.env:dev`** The instance's name is howl and it has
     *       the label env with value dev.
     * @property {number} [pageSize] Maximum number of results per page.
     * @property {string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @property {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @typedef {array} GetSessionsResponse
     * @property {Session[]} 0 Array of {@link Session} instances.
     * @property {object} 1 A query object to receive more results.
     * @property {object} 2 The full API response.
     */
    /**
     * @callback GetSessionsCallback
     * @param {?Error} err Request error, if any.
     * @param {Session[]} instances Array of {@link Session} instances.
     * @param {object} nextQuery A query object to receive more results.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Gets a list of sessions.
     *
     * Wrapper around {@link v1.SpannerClient#listSessions}
     *
     * @see {@link v1.SpannerClient#listSessions}
     * @see [ListSessions API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ListSessions)
     *
     * @param {GetSessionsOptions} [options] Options object for listing sessions.
     * @param {GetSessionsCallback} [callback] Callback function.
     * @returns {Promise<GetSessionsResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSessions(function(err, sessions) {
     *   // `sessions` is an array of `Session` objects.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * function callback(err, sessions, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     database.getSessions(nextQuery, callback);
     *   }
     * }
     *
     * database.getInstances({
     *   gaxOptions: {autoPaginate: false}
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.getInstances().then(function(data) {
     *   const sessions = data[0];
     * });
     * ```
     */
    getSessions(options?: GetSessionsOptions): Promise<GetSessionsResponse>;
    getSessions(callback: GetSessionsCallback): void;
    getSessions(options: GetSessionsOptions, callback: GetSessionsCallback): void;
    /**
     * Get a list of sessions as a readable object stream.
     *
     * Wrapper around {@link v1.SpannerClient#listSessions}
     *
     * @see {@link v1.SpannerClient#listSessions}
     * @see [ListSessions API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ListSessions)
     *
     * @method Spanner#getSessionsStream
     * @param {GetSessionsOptions} [options] Options object for listing sessions.
     * @returns {ReadableStream} A readable stream that emits {@link Session}
     *     instances.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSessionsStream()
     *   .on('error', console.error)
     *   .on('data', function(database) {
     *     // `sessions` is a `Session` object.
     *   })
     *   .on('end', function() {
     *     // All sessions retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.getSessionsStream()
     *   .on('data', function(session) {
     *     this.end();
     *   });
     * ```
     */
    getSessionsStream(options?: GetSessionsOptions): NodeJS.ReadableStream;
    /**
     * @typedef {array} GetSnapshotResponse
     * @property {Snapshot} 0 The snapshot object.
     */
    /**
     * @callback GetSnapshotCallback
     * @param {?Error} err Request error, if any.
     * @param {Snapshot} snapshot The snapshot object.
     */
    /**
     * Get a read only {@link Snapshot} transaction.
     *
     * Wrapper around {@link v1.SpannerClient#beginTransaction}.
     *
     * **NOTE:** When finished with the Snapshot, {@link Snapshot#end} should be
     * called to release the underlying {@link Session}. **Failure to do could
     * result in a Session leak.**
     *
     * **NOTE:** Since the returned {@link Snapshot} transaction is not a
     * single-use transaction, it is invalid to set the `minReadTimestamp` and
     * `maxStaleness` parameters in {@link TimestampBounds} as those parameters
     * can only be set for single-use transactions.
     * https://cloud.google.com/spanner/docs/reference/rest/v1/TransactionOptions#bounded-staleness
     *
     * @see {@link v1.SpannerClient#beginTransaction}
     *
     * @param {TimestampBounds} [options] Timestamp bounds.
     * @param {GetSnapshotCallback} [callback] Callback function.
     * @returns {Promise<GetSnapshotResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSnapshot(function(err, transaction) {
     *   if (err) {
     *    // Error handling omitted.
     *   }
     *
     *   // Should be called when finished with Snapshot.
     *   transaction.end();
     * });
     * ```
     *
     * @example If the callback is omitted, we'll return a Promise.
     * ```
     * database.getSnapshot().then(function(data) {
     *   const transaction = data[0];
     * });
     * ```
     *
     * @example <caption>include:samples/transaction.js</caption>
     * region_tag:spanner_read_only_transaction
     * Read-only transaction:
     */
    getSnapshot(options?: TimestampBounds): Promise<[Snapshot]>;
    getSnapshot(callback: GetSnapshotCallback): void;
    getSnapshot(options: TimestampBounds, callback: GetSnapshotCallback): void;
    /**
     * @typedef {array} GetTransactionResponse
     * @property {Transaction} 0 The transaction object.
     */
    /**
     * @callback GetTransactionCallback
     * @param {?Error} err Request error, if any.
     * @param {Transaction} transaction The transaction object.
     */
    /**
     * Get a read/write ready {@link Transaction} object.
     *
     * **NOTE:** In the event that you encounter an error while reading/writing,
     * if you decide to forgo calling {@link Transaction#commit} or
     * {@link Transaction#rollback}, then you need to call
     * {@link Transaction#end} to release the underlying {@link Session} object.
     * **Failure to do could result in a Session leak.**
     *
     * Wrapper around {@link v1.SpannerClient#beginTransaction}.
     *
     * @see {@link v1.SpannerClient#beginTransaction}
     *
     * @param {GetTransactionCallback} [callback] Callback function.
     * @returns {Promise<GetTransactionResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getTransaction(function(err, transaction) {});
     *
     * ```
     * @example If the callback is omitted, we'll return a Promise.
     * ```
     * database.getTransaction().then(function(data) {
     *   const transaction = data[0];
     * });
     * ```
     */
    getTransaction(optionsOrCallback?: GetTransactionOptions): Promise<[Transaction]>;
    getTransaction(callback: GetTransactionCallback): void;
    /**
     * Query object for listing database operations.
     *
     * @typedef {object} GetDatabaseOperationsOptions
     * @property {string} [filter] An expression for filtering the results of the
     *     request. Filter can be configured as outlined in
     *     {@link v1.DatabaseAdminClient#listDatabaseOperations}.
     * @property {number} [pageSize] Maximum number of results per page.
     * @property {string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @property {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetDatabaseOperationsCallback} [callback] Callback function.
     */
    /**
     * @typedef {array} GetDatabaseOperationsResponse
     * @property {IOperation[]} 0 Array of {@link IOperation} instances.
     * @property {object} 1 The full API response.
     */
    /**
     * List pending and completed operations for the database.
     *
     * @see {@link Instance.getDatabaseOperations}
     *
     * @param {GetDatabaseOperationsOptions} [options] Contains query object for
     *     listing database operations and request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @returns {Promise<GetDatabaseOperationsResponse>} When resolved, contains
     *     a paged list of database operations.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const [operations] = await database.getOperations();
     *
     * //-
     * // To manually handle pagination, set autoPaginate:false in gaxOptions.
     * //-
     * let pageToken = undefined;
     * do {
     *   const [operations, , response] = await database.getOperations({
     *     pageSize: 3,
     *     pageToken,
     *     gaxOptions: {autoPaginate: false},
     *   });
     *   operations.forEach(operation => {
     *     // Do something with operation
     *   });
     *   pageToken = response.nextPageToken;
     * } while (pageToken);
     * ```
     */
    getOperations(options?: GetDatabaseOperationsOptions): Promise<GetDatabaseOperationsResponse>;
    getOperations(callback: GetDatabaseOperationsCallback): void;
    getOperations(options: GetDatabaseOperationsOptions, callback: GetDatabaseOperationsCallback): void;
    /**
     * @typedef {array} GetDatabaseRolesResponse
     * @property {IDatabaseRolees[]} 0 Array of list of database roles.
     * @property {object} 1 A query object to receive more results.
     * @property {object} 2 The full API response.
     */
    /**
     * @callback GetDatabaseRolesCallback
     * @param {?Error} err Request error, if any.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Gets a list of database roles
     *
     * @see {@link v1.DatabaseAdminClient#getDatabaseRoles}
     * @see [GetDatabaseRoles API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseRoles)
     *
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {GetDatabaseRolesCallback} [callback] Callback function.
     * @returns {Promise<GetDatabaseRolesResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getDatabaseRoles(function(err, roles) {
     *   // `roles` is an array of `DatabaseRoles` objects.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * function callback(err, roles, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     database.getDatabaseRoles(nextQuery, callback);
     *   }
     * }
     *
     * database.getInstances({
     *   gaxOptions: {autoPaginate: false}
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.getInstances().then(function(data) {
     *   const roles = data[0];
     * });
     * ```
     */
    getDatabaseRoles(gaxOptions?: CallOptions): Promise<GetDatabaseRolesResponse>;
    getDatabaseRoles(callback: GetDatabaseRolesCallback): void;
    getDatabaseRoles(gaxOptions: CallOptions, callback: GetDatabaseRolesCallback): void;
    /**
     * Make an API request, first assuring an active session is used.
     *
     * @private
     *
     * @param {object} config Request config
     * @param {function} callback Callback function
     */
    makePooledRequest_(config: RequestConfig): Promise<Session>;
    makePooledRequest_(config: RequestConfig, callback: PoolRequestCallback): void;
    /**
     * Make an API request as a stream, first assuring an active session is used.
     *
     * @private
     *
     * @param {object} config Request config
     * @returns {Stream}
     */
    makePooledStreamingRequest_(config: RequestConfig): Readable;
    /**
     * @typedef {object} RestoreOptions
     * @property {google.spanner.admin.database.v1.IRestoreDatabaseEncryptionConfig}
     *     encryptionConfig An encryption configuration describing
     *     the encryption type and key resources in Cloud KMS used to
     *     encrypt/decrypt the database to restore to.
     * @property {CallOptions} [gaxOptions] The request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     */
    /**
     * @typedef {array} RestoreDatabaseResponse
     * @property {Database} 0 The new {@link Database}.
     * @property {google.longrunning.Operation} 1 An {@link Operation} object that can be used to check
     *     the status of the request.
     * @property {object} 2 The full API response.
     */
    /**
     * @callback RestoreDatabaseCallback
     * @param {?Error} err Request error, if any.
     * @param {Database} database The new {@link Database}.
     * @param {google.longrunning.Operation} operation An {@link Operation} object that can be used to
     *     check the status of the request.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Restore a backup into this database.
     *
     * When this call completes, the restore will have commenced but will not
     * necessarily have completed.
     *
     * @param {string} backupPath The path of the backup to restore.
     * @param {RestoreOptions} [options] Request configuration options.
     * @param {RestoreDatabaseCallback} [callback] Callback function.
     * @returns {Promise<RestoreDatabaseResponse>} When resolved, contains the restore operation.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const backupName = 'projects/my-project/instances/my-instance/backups/my-backup';
     * const [, restoreOperation] = await database.restore(backupName);
     * // Wait for restore to complete
     * await restoreOperation.promise();
     *
     * //-
     * // Restore database with a different encryption key to the one used by the
     * // backup.
     * //-
     * const [, restoreWithKeyOperation] = await database.restore(
     *   backupName,
     *   {
     *     encryptionConfig: {
     *       encryptionType: 'CUSTOMER_MANAGED_ENCRYPTION',
     *       kmsKeyName: 'projects/my-project-id/my-region/keyRings/my-key-ring/cryptoKeys/my-key',
     *     }
     *   },
     * );
     * // Wait for restore to complete
     * await restoreWithKeyOperation.promise();
     * ```
     */
    restore(backupPath: string): Promise<RestoreDatabaseResponse>;
    restore(backupPath: string, options?: RestoreOptions | CallOptions): Promise<RestoreDatabaseResponse>;
    restore(backupPath: string, callback: RestoreDatabaseCallback): void;
    restore(backupPath: string, options: RestoreOptions | CallOptions, callback: RestoreDatabaseCallback): void;
    /**
     * Transaction options.
     *
     * @typedef {object} DatabaseRunRequest
     * @property {number} [exactStaleness] Executes all reads at the timestamp
     *     that is `exactStaleness` old.
     * @property {date} [readTimestamp] Execute all reads at the given
     *     timestamp.
     * @property {boolean} [strong] Read at the timestamp where all previously
     *     committed transactions are visible.
     */
    /**
     * @typedef {array} RunResponse
     * @property {Array<Row | Json>} 0 Rows are returned as an array objects. Each
     *     object has a `name` and `value` property. To get a serialized object,
     *     call `toJSON()`.
     * @property {?google.spanner.v1.IResultSetStats} 1 Query statistics, if the query is executed in
     *     PLAN or PROFILE mode.
     */
    /**
     * @callback RunCallback
     * @param {?Error} err Request error, if any.
     * @param {Array<Row | Json>} rows Rows are returned as an array of objects.
     *     Each object has a `name` and `value` property. To get a serialized
     *     object, call `toJSON()`.
     * @param {?google.spanner.v1.IResultSetStats} stats Query statistics, if the query is executed
     *     in PLAN or PROFILE mode.
     */
    /**
     * Execute a SQL statement on this database.
     *
     * Wrapper around {@link v1.SpannerClient#executeStreamingSql}.
     *
     * @see {@link v1.SpannerClient#executeStreamingSql}
     * @see [Query Syntax](https://cloud.google.com/spanner/docs/query-syntax)
     * @see [ExecuteSql API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteSql)
     *
     * @param {string|ExecuteSqlRequest} query A SQL query or
     *     {@link ExecuteSqlRequest} object.
     * @param {TimestampBounds} [options] Snapshot timestamp bounds.
     * @param {RunCallback} [callback] Callback function.
     * @returns {Promise<RunResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const query = 'SELECT * FROM Singers';
     *
     * database.run(query, function(err, rows) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   const firstRow = rows[0];
     *
     *   // firstRow = [
     *   //   {
     *   //     name: 'SingerId',
     *   //     value: '1'
     *   //   },
     *   //   {
     *   //     name: 'Name',
     *   //     value: 'Eddie Wilson'
     *   //   }
     *   // ]
     * });
     *
     * //-
     * // Rows are returned as an array of object arrays. Each object has a `name`
     * // and `value` property. To get a serialized object, call `toJSON()`.
     * //-
     * database.run(query, function(err, rows) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   const firstRow = rows[0];
     *
     *   // firstRow.toJSON() = {
     *   //   SingerId: '1',
     *   //   Name: 'Eddie Wilson'
     *   // }
     * });
     *
     * //-
     * // Alternatively, set `query.json` to `true`, and this step will be performed
     * // automatically.
     * //-
     * database.run(query, function(err, rows) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   const firstRow = rows[0];
     *
     *   // firstRow = {
     *   //   SingerId: '1',
     *   //   Name: 'Eddie Wilson'
     *   // }
     * });
     *
     * //-
     * // The SQL query string can contain parameter placeholders. A parameter
     * // placeholder consists of '@' followed by the parameter name.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   }
     * };
     *
     * database.run(query, function(err, rows) {});
     *
     * //-
     * // If you need to enforce a specific param type, a types map can be provided.
     * // This is typically useful if your param value can be null.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name AND id = @id',
     *   params: {
     *     id: spanner.int(8),
     *     name: null
     *   },
     *   types: {
     *     id: 'int64',
     *     name: 'string'
     *   }
     * };
     *
     * database.run(query, function(err, rows) {});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.run(query).then(function(data) {
     *   const rows = data[0];
     * });
     *
     * ```
     * @example <caption>include:samples/crud.js</caption>
     * region_tag:spanner_query_data
     * Full example:
     *
     * @example <caption>include:samples/index-query-data.js</caption>
     * region_tag:spanner_query_data_with_index
     * Querying data with an index:
     */
    run(query: string | ExecuteSqlRequest): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, options?: TimestampBounds): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, callback: RunCallback): void;
    run(query: string | ExecuteSqlRequest, options: TimestampBounds, callback: RunCallback): void;
    /**
     * Partitioned DML transactions are used to execute DML statements with a
     * different execution strategy that provides different, and often better,
     * scalability properties for large, table-wide operations than DML in a
     * Transaction transaction. Smaller scoped statements, such as an OLTP workload,
     * should prefer using Transaction transactions.
     *
     * @see {@link Transaction#runUpdate}
     *
     * @param {string|ExecuteSqlRequest} query A DML statement or
     *     {@link ExecuteSqlRequest} object.
     * @param {RunUpdateCallback} [callback] Callback function.
     * @returns {Promise<RunUpdateResponse>}
     */
    runPartitionedUpdate(query: string | RunPartitionedUpdateOptions): Promise<[number]>;
    runPartitionedUpdate(query: string | RunPartitionedUpdateOptions, callback?: RunUpdateCallback): void;
    _runPartitionedUpdate(session: Session, query: string | RunPartitionedUpdateOptions, callback?: RunUpdateCallback): void | Promise<number>;
    /**
     * Create a readable object stream to receive resulting rows from a SQL
     * statement.
     *
     * Wrapper around {@link v1.SpannerClient#executeStreamingSql}.
     *
     * @see {@link v1.SpannerClient#executeStreamingSql}
     * @see [Query Syntax](https://cloud.google.com/spanner/docs/query-syntax)
     * @see [ExecuteSql API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteSql)
     *
     * @fires PartialResultStream#response
     *
     * @param {string|ExecuteSqlRequest} query A SQL query or
     *     {@link ExecuteSqlRequest} object.
     * @param {TimestampBounds} [options] Snapshot timestamp bounds.
     * @returns {PartialResultStream} A readable stream that emits rows.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const query = 'SELECT * FROM Singers';
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = [
     *     //   {
     *     //     name: 'SingerId',
     *     //     value: '1'
     *     //   },
     *     //   {
     *     //     name: 'Name',
     *     //     value: 'Eddie Wilson'
     *     //   }
     *     // ]
     *   // ]
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Rows are returned as an array of objects. Each object has a `name` and
     * // `value` property. To get a serialized object, call `toJSON()`.
     * //-
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row.toJSON() = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Alternatively, set `query.json` to `true`, and this step will be performed
     * // automatically.
     * //-
     * query.json = true;
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // The SQL query string can contain parameter placeholders. A parameter
     * // placeholder consists of '@' followed by the parameter name.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you need to enforce a specific param type, a types map can be provided.
     * // This is typically useful if your param value can be null.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   },
     *   types: {
     *     name: 'string'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.runStream(query)
     *   .on('data', function(row) {
     *     this.end();
     *   });
     * ```
     */
    runStream(query: string | ExecuteSqlRequest, options?: TimestampBounds): PartialResultStream;
    /**
     * @typedef {object} RunTransactionOptions
     * @property {number} [timeout] The maximum amount of time (in ms) that a
     *     {@link Transaction} should be ran for.
     */
    /**
     * @callback RunTransactionCallback
     * @param {?Error} err An error returned while making this request.
     * @param {Transaction} transaction The transaction object. The transaction has
     *     already been created, and is ready to be queried and committed against.
     */
    /**
     * A transaction in Cloud Spanner is a set of reads and writes that execute
     * atomically at a single logical point in time across columns, rows, and tables
     * in a database.
     *
     * Note that Cloud Spanner does not support nested transactions. If a new
     * transaction is started inside of the run function, it will be an independent
     * transaction.
     *
     * The callback you provide to this function will become the "run function". It
     * will be executed with either an error or a {@link Transaction}
     * object. The Transaction object will let you run queries and queue mutations
     * until you are ready to {@link Transaction#commit}.
     *
     * In the event that an aborted error occurs, we will re-run the `runFn` in its
     * entirety. If you prefer to handle aborted errors for yourself please refer to
     * {@link Database#getTransaction}.
     *
     * **NOTE:** In the event that you encounter an error while reading/writing,
     * if you decide to forgo calling {@link Transaction#commit} or
     * {@link Transaction#rollback}, then you need to call
     * {@link Transaction#end} to release the underlying {@link Session} object.
     * **Failure to do could result in a Session leak.**
     *
     * For a more complete listing of functionality available to a Transaction, see
     * the {@link Transaction} API documentation. For a general overview of
     * transactions within Cloud Spanner, see
     * [Transactions](https://cloud.google.com/spanner/docs/transactions) from the
     * official Cloud Spanner documentation.
     *
     * If you would like to run a transaction and receive a promise or use
     * async/await, use {@link Database#runTransactionAsync}.
     *
     * @see [Transactions](https://cloud.google.com/spanner/docs/transactions)
     *
     * @param {RunTransactionOptions} [options] Transaction runner options.
     * @param {RunTransactionCallback} callback A function to execute in the context
     *     of a transaction.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.runTransaction(function(err, transaction) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   // Run a transactional query.
     *   transaction.run('SELECT * FROM Singers', function(err, rows) {
     *     if (err) {
     *       // Error handling omitted.
     *     }
     *
     *     // Queue a mutation (note that there is no callback passed to `insert`).
     *     transaction.insert('Singers', {
     *       SingerId: 'Id3b',
     *       Name: 'Joe West'
     *     });
     *
     *     // Commit the transaction.
     *     transaction.commit(function(err) {
     *       if (!err) {
     *         // Transaction committed successfully.
     *       }
     *     });
     *   });
     * });
     *
     * ```
     * @example <caption>include:samples/transaction.js</caption>
     * region_tag:spanner_read_write_transaction
     * Read-write transaction:
     */
    runTransaction(runFn: RunTransactionCallback): void;
    runTransaction(options: RunTransactionOptions, runFn: RunTransactionCallback): void;
    runTransactionAsync<T = {}>(runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    runTransactionAsync<T = {}>(options: RunTransactionOptions, runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    /**
     * Write a batch of mutations to Spanner.
     *
     * All mutations in a group are committed atomically. However, mutations across
     * groups can be committed non-atomically in an unspecified order and thus, they
     * must be independent of each other. Partial failure is possible, i.e., some groups
     * may have been committed successfully, while some may have failed. The results of
     * individual batches are streamed into the response as the batches are applied.
     *
     * batchWriteAtLeastOnce requests are not replay protected, meaning that each mutation group may
     * be applied more than once. Replays of non-idempotent mutations may have undesirable
     * effects. For example, replays of an insert mutation may produce an already exists
     * error or if you use generated or commit timestamp-based keys, it may result in additional
     * rows being added to the mutation's table. We recommend structuring your mutation groups to
     * be idempotent to avoid this issue.
     *
     * @method Spanner#batchWriteAtLeastOnce
     *
     * @param {MutationGroup[]} [mutationGroups] The group of mutations to be applied.
     * @param {BatchWriteOptions} [options] Options object for batch write request.
     *
     * @returns {ReadableStream} An object stream which emits
     *   {@link protos.google.spanner.v1.BatchWriteResponse|BatchWriteResponse}
     *  on 'data' event.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const mutationGroup = new MutationGroup();
     * mutationGroup.insert('Singers', {
     *  SingerId: '1',
     *  FirstName: 'Marc',
     *  LastName: 'Richards',
     *  });
     *
     * database.batchWriteAtLeastOnce([mutationGroup])
     *   .on('error', console.error)
     *   .on('data', response => {
     *        console.log('response: ', response);
     *   })
     *   .on('end', () => {
     *        console.log('Request completed successfully');
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.batchWriteAtLeastOnce()
     *   .on('data', response => {
     *     this.end();
     *   });
     * ```
     */
    batchWriteAtLeastOnce(mutationGroups: MutationGroup[], options?: BatchWriteOptions): NodeJS.ReadableStream;
    /**
     * Write mutations using a single RPC invocation without replay protection.
     *
     * writeAtLeastOnce writes mutations to Spanner using a single Commit RPC.
     * These requests are not replay protected, meaning that it may apply mutations more
     * than once, if the mutations are not idempotent, this may lead to a failure being
     * reported when the mutation was applied once. Replays non-idempotent mutations may
     * have undesirable effects. For example, replays of an insert mutation may produce an
     * already exists error. For this reason, most users of the library will prefer to use
     * {@link runTransaction} instead.
     *
     * However, {@link writeAtLeastOnce()} requires only a single RPC, whereas {@link runTransaction()}
     * requires two RPCs (one of which may be performed in advance), and so this method may be
     * appropriate for latency sensitive and/or high throughput blind writing.
     *
     * We recommend structuring your mutation set to be idempotent to avoid this issue.
     *
     * @param {MutationSet} [mutations] Set of Mutations to be applied.
     * @param {CallOptions} [options] Options object for blind write request.
     * @param {CommitCallback} [callback] Callback function for blind write request.
     *
     * @returns {Promise}
     *
     * @example
     * ```
     * const {Spanner, MutationSet} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const mutations = new MutationSet();
     * mutations.upsert('Singers', {
     *    SingerId: 1,
     *    FirstName: 'Scarlet',
     *    LastName: 'Terry',
     *  });
     * mutations.upsert('Singers', {
     *    SingerId: 2,
     *    FirstName: 'Marc',
     *    LastName: 'Richards',
     *  });
     *
     * try {
     *  const [response] = await database.writeAtLeastOnce(mutations, {});
     *  console.log(response.commitTimestamp);
     * } catch(err) {
     *  console.log("Error: ", err);
     * }
     * ```
     */
    writeAtLeastOnce(mutations: MutationSet): Promise<CommitResponse>;
    writeAtLeastOnce(mutations: MutationSet, options: WriteAtLeastOnceOptions): Promise<CommitResponse>;
    writeAtLeastOnce(mutations: MutationSet, callback: CommitCallback): void;
    writeAtLeastOnce(mutations: MutationSet, options: WriteAtLeastOnceOptions, callback: CommitCallback): void;
    /**
     * Create a Session object.
     *
     * It is unlikely you will need to interact with sessions directly. By default,
     * sessions are created and utilized for maximum performance automatically.
     *
     * @param {string} [name] The name of the session. If not provided, it is
     *     assumed you are going to create it.
     * @returns {Session} A Session object.
     *
     * @example
     * ```
     * var session = database.session('session-name');
     * ```
     */
    session(name?: string): Session;
    /**
     * Get a reference to a Table object.
     *
     * @throws {GoogleError} If a name is not provided.
     *
     * @param {string} name The name of the table.
     * @return {Table} A Table object.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const table = database.table('Singers');
     * ```
     */
    /**
     * @callback SetIamPolicyCallback
     * @param {?Error} err Request error, if any.
     * @param {google.iam.v1.Policy| undefined} policy Returns policy for the give database
     */
    /**
     * Sets the policy for the database.
     *
     * A Policy is a collection of bindings. A binding binds one or more members, or principals,
     * to a single role. Principals can be user accounts, service accounts, Google groups, and
     * domains (such as G Suite). A role is a named list of permissions; each role can be an IAM
     * predefined role or a user-created custom role.
     *
     * @see {@link #setIamPolicy}
     *
     * @method Database#setIamPolicy
     * @param {object} [policy] requestedPolicyVersion and gax options(configuration options)
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html}
     *     for more details on gax options.
     * @param {object} [options] Requested configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html}
     *     for more details on Call Options.
     * @param {SetIamPolicyCallback} [callback] Callback function.
     * @returns {Promise<Policy | undefined>}
     *     When resolved, contains the current policy of the database.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     * const binding = {
     *     role: 'roles/spanner.fineGrainedAccessUser',
     *     members: ['user:asthamohta@google.com'],
     *     condition: {
     *         title: 'new condition',
     *         expression: 'resource.name.endsWith("/databaseRoles/parent")',
     *     },
     * };
     * const policy = {
     *     bindings: [newBinding],
     *     version: 3,
     *};
     * const policy = await database.setIamPolicy({policy: policy});
     * ```
     */
    setIamPolicy(policy: SetIamPolicyRequest): Promise<SetIamPolicyResponse>;
    setIamPolicy(policy: SetIamPolicyRequest, options?: CallOptions): Promise<SetIamPolicyResponse>;
    setIamPolicy(policy: SetIamPolicyRequest, callback: SetIamPolicyCallback): void;
    setIamPolicy(policy: SetIamPolicyRequest, options: CallOptions, callback: SetIamPolicyCallback): void;
    table(name: string): Table;
    /**
     * Update the schema of the database by creating/altering/dropping tables,
     * columns, indexes, etc.
     *
     * This method immediately responds with an Operation object. Register event
     * handlers for the "error" and "complete" events to see how the operation
     * finishes. Follow along with the examples below.
     *
     * Wrapper around {@link v1.DatabaseAdminClient#updateDatabaseDdl}.
     *
     * @see {@link v1.DatabaseAdminClient#updateDatabaseDdl}
     * @see [Data Definition Language (DDL)](https://cloud.google.com/spanner/docs/data-definition-language)
     * @see [Schema and Data Model](https://cloud.google.com/spanner/docs/schema-and-data-model)
     * @see [UpdateDatabaseDdl API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.UpdateDatabaseDdlRequest)
     *
     * @param {string|string[]|object} statements An array of database DDL
     *     statements, or an
     *     [`UpdateDatabaseDdlRequest` object](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.admin.database.v1#google.spanner.admin.database.v1.UpdateDatabaseDdlRequest).
     * @param {object} [gaxOptions] Request configuration options,
     *     See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions}
     *     for more details.
     * @param {LongRunningOperationCallback} [callback] Callback function.
     * @returns {Promise<LongRunningOperationResponse>}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const statements = [
     *   'CREATE TABLE Singers (' +
     *   '  SingerId INT64 NOT NULL,' +
     *   '  FirstName STRING(1024),' +
     *   '  LastName STRING(1024),' +
     *   '  SingerInfo BYTES(MAX),' +
     *   ') PRIMARY KEY(SingerId)'
     * ];
     *
     * database.updateSchema(statements, function(err, operation, apiResponse) {
     *   if (err) {
     *     // Error handling omitted.
     *   }
     *
     *   operation
     *     .on('error', function(err) {})
     *     .on('complete', function() {
     *       // Database schema updated successfully.
     *     });
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * database.updateSchema(statements)
     *   .then(function(data) {
     *     const operation = data[0];
     *     return operation.promise();
     *   })
     *   .then(function() {
     *     // Database schema updated successfully.
     *   });
     *
     * ```
     * @example <caption>include:samples/schema.js</caption>
     * region_tag:spanner_add_column
     * Adding a column:
     *
     * @example <caption>include:samples/index-create.js</caption>
     * region_tag:spanner_create_index
     * Creating an index:
     *
     * @example <caption>include:samples/index-create-stroing.js</caption>
     * region_tag:spanner_create_storing_index
     * Creating a storing index:
     */
    updateSchema(statements: Schema, gaxOptions?: CallOptions): Promise<UpdateSchemaResponse>;
    updateSchema(statements: Schema, callback: UpdateSchemaCallback): void;
    updateSchema(statements: Schema, gaxOptions: CallOptions, callback: UpdateSchemaCallback): void;
    /**
     * Format the database name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * ```
     * Database.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-database'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/databases/my-database'
     * ```
     */
    static formatName_(instanceName: string, name: string): string;
    /**
     * Gets the Spanner object
     *
     * @private
     *
     * @returns {Spanner}
     */
    private _getSpanner;
}
/**
 * Reference to the {@link Database} class.
 * @name module:@google-cloud/spanner.Database
 * @see Database
 */
export { Database };
